#include <iostream>

void Swap(int* a, int* b)
{
	int temp = *a;
	*a = *b;
	*b = temp;
}

void Swap(int& a, int& b)
{
	int temp = a;
	a = b;
	b = temp;
}

int main()
{
	// 포인터 : 메모리 주소
	// 포인터의 크기는 레지스터의 크기와 동일(32비트 컴퓨터에선 4바이트, 64비트 환경이면 8바이트)

	// 사용 예시
	/*
		1. 배열 및 구조체에 대한 편리한 접근
		2. 참조에 의한 호출(Call By Reference)
		3. 동적 메모리 관리
		4. 함수 포인터
	*/
	// 장점
	/*
		1. 배열 및 구조체의 효율적 전달(사이즈가 큰 배열이나 구조체를 복사하지 않고 직접 전달)
		2. 메모리 직접 제어, 동적 할당
		3. 전역 변수 사용 최소화 (참조 호출로 대체)
	*/
	// 단점
	/*
		1. 읽기 어려움 (가독성 저하)
		2. 잘못된 메모리 관리 시 안정성 저하
		3. 버그 발견이 어려움
	*/

	//-------------------------------------------------------------------------------------------------------------
	
	int a{ 1 };

	// 타입* (포인터) : 해당 타입을 가리키는 포인터 변수형. 메모리 주소값을 입력받으며, 메모리 주소가 들어 있다.
	int* ptr{ &a };
	// 타입& (참조형) : 해당 타입을 가리키는 참조 변수형. 해당 타입의 변수를 입력받으며, 변수의 주소를 담고 있다. -> 그냥은 거의 안 쓰고, 함수의 매개변수로 주로 사용됨.
	int& ref{ a };




	// 변수에 &를 붙이면 해당 변수가 들어있는 메모리 주소값을 의미한다.
	// 포인터에 *를 붙이면 해당 주소에 들어있는 값을 의미한다.
	std::cout << &a << " : " << a << std::endl;
	std::cout << ptr << " : " << *ptr << std::endl;

	// 빈 포인터는 아래와 같은 형태로 가능한데, 모던 C++에선 포인터 값임이 보장되는 nullptr을 사용한다.
	ptr = nullptr;
	ptr = 0;
	ptr = NULL; //#define에 의해 컴파일 때 0으로 변경됨

	// 포인터를 이용하면 변수 값을 복사하는 게 아닌, 변수의 주소 자체를 넘겨줄 수 있다.
	// 이렇게 하면 함수 내에서 넘겨준 변수의 값을 조작할 수 있다.
	// 기존의 값 복사 방식을 '값에 의한 호출(Call By Value)', 포인터를 이용하여 변수 자체를 넘기는 방식을 '참조에 의한 호출(Call Bu Reference)' 이라고 부른다.
	int x{ 10 }, y{ 20 };
	Swap(&x, &y);
	std::cout << "(x, y) = " << x << ", " << y << std::endl;




	// 변수& 타입은 가리키고 있는 변수의 값을 반환한다. (변수* 타입은 주소값 자체를 반환)
	std::cout << ref << " : " << a << std::endl;

	// 변수& 타입에 값을 대입하면, 자신이 가리키는 변수의 값에 대입된다.
	int b{ 2 };
	ref = b; // ref는 a를 가리키므로, a에는 b의 값인 2가 대입된다.

	std::cout << ref << " : " << a << std::endl;

	// 변수& 타입은 값을 대입할 수 있으므로, 함수에 참조형 변수를 넘길 때 *, & 기호를 사용할 필요가 없어 표기가 간소화된다.
	x = 10, y = 20;
	Swap(x, y);
	std::cout << "(x, y) = " << x << ", " << y << std::endl;

	//변수& 타입은 초기화 때 빈 값을 넣을 수 없고, 반드시 변수가 들어 있어야 한다.
}